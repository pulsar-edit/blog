
// Some helpers to handle the generation of paginated tag lists and category
// lists.
//
// 11ty has an example of how to build “tag pages” for a blog…
//
//   https://www.11ty.dev/docs/quicktips/tag-pages/
//
// …but there's a crucial shortcoming: by using pagination to generate each tag
// page, we're unable to use it to paginate the list of posts for that tag.
// We need _double-pagination_ of some sort.
//
// This blog post sent me in the right direction:
//
//   https://desmondrivet.com/2022/03/23/eleventy-pagination
//
// I’ve customized and enhanced this technique a bit; for instance, since 11ty
// doesn’t generate a `pagination` object to use in page navigation, I had to
// construct one on my own.

// Index posts by a string key. Accepts a `keyFn` that, when called with a
// `post` object, points to the string value that should be used to index it.
function indexPostsBy (allPosts, keyFn) {
  let index = {};
  for (let post of allPosts) {
    for (let tag of keyFn(post) ?? []) {
      index[tag] ??= [];
      index[tag].push(post);
    }
  }
  return index;
}

// Given a collection, splits it into chunks of the given size. The last chunk
// will have the remainder.
function chunk (collection, chunkSize) {
  let chunks = [];
  let currentChunk = [];
  for (let i = 0; i < collection.length; i++) {
    let item = collection[i];
    currentChunk.push(item);
    if (currentChunk.length === chunkSize || i === collection.length - 1) {
      chunks.push(currentChunk);
      currentChunk = [];
    }
  }
  return chunks;
}

// Given an indexed post object of the sort generated by `indexPostsBy`,
// generate pages of the given `chunkSize` and other useful data for rendering.
function flatPaginate (indexedCollection, { chunkSize, slug, title = ((x) => x) } = {}) {
  let pages = [];
  let index = {};
  for (let tag of Object.keys(indexedCollection)) {
    let pagedItems = chunk(indexedCollection[tag], chunkSize);
    index[tag] ??= [];
    let hrefs = [];
    for (let pageNumber = 0; pageNumber < pagedItems.length; pageNumber++) {
      // Generate a URL for each page in the list. The first page is
      // available at `/foo/`; the second at `/foo/2/`; and so on.
      let href = `/${slug}/${tag}/${pageNumber > 0 ? `${pageNumber + 1}/` : '' }`
      index[tag].push({
        name: tag,
        page: pageNumber,
        total: pagedItems.length,
        items: pagedItems[pageNumber],

        // Later on we'll tell 11ty to use this `href` and `title` as the
        // canonical page title and permalink.
        href: href,
        title: title(tag)
      });
      hrefs.push(href);
    }

    // Now that we've generated all the pages, we'll do a second pass so that
    // each paginated collection can have a `pagination` object that
    // corresponds to what we'd get from 11ty for free.
    for (let i = 0; i < index[tag].length; i++) {
      let href = {};
      if (i > 0) {
        href.previous = index[tag][i - 1].href;
      }
      if (i < (index[tag].length - 1)) {
        href.next = index[tag][i + 1].href;
      }
      index[tag][i].pagination = { href, hrefs };
    }
  }

  // Now we can flatten all our entries into a list of pages. When an 11ty
  // page uses this collection in its front matter, it'll paginate with a
  // `size` of `1` so that each of these pages is given its own page.
  //
  // 11ty will generate pagination data automatically, but it won't be useful
  // for our purposes, since that's not how we want users to navigate through
  // the list. That's why we built a custom `pagination` object above.
  for (let tag of Object.keys(index)) {
    for (let i = 0; i < index[tag].length; i++) {
      pages.push(index[tag][i]);
    }
  }

  return pages;
}

module.exports = {
  indexPostsBy,
  flatPaginate
};
